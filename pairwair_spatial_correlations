#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, re, glob, pickle, csv
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# ======================
# CONFIG — set these
# ======================
WHICH_ANIMAL = "MimosaPudica"  # Arwen | Tauriel | PreciousGrape | ToothMuch | MimosaPudica

# Time-resolved ETC for even/odd (EO) computation
TIME_RESOLVED_ETC = "/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/rm_pre_data_mimosapudica_chasingmerged_EBC_ETC_XYZeuler_notricks_eo.pkl"

# Per-cell PKL folders (or files) that contain full-session maps
# If they’re all in one folder, just list it three times; stems decide which keys are taken.
PERCELL_INPUTS_ETC      = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_chasing_ETC_EBC"]
PERCELL_INPUTS_EBC      = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_chasing_ETC_EBC"]
PERCELL_INPUTS_EOC      = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_objectmerged_day0_sqaure"]
PERCELL_INPUTS_ETC_PRIM = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_nopursuitmerged"]  # ETC′ (no pursuit)


# ETC covariates for time-resolved EO
ANGLE_KEY = 'S Relative_head_angle'
DIST_KEY  = 'T Relative_distance'

# 2D binning
ANGLE_EDGES = np.linspace(-180, 180, 37)   # 10° bins
DIST_EDGES  = np.linspace(0, 150, 31)      # 5 cm bins
SMOOTH_SIGMA = 1.0
MIN_OVERLAP_BINS = 20

# Optional CSV (set "" to skip)
CSV_OUT = ""  # e.g. "/tmp/pairwise_corrs_with_eo.csv"

# ======================
# Channel map
# ======================
channel_ranges = {
    'Arwen': {'RSC': range(124, 385), 'SC': range(0, 124)},
    'Tauriel': {'RSC': range(190, 385), 'SC': range(0, 190)},
    'PreciousGrape': {'RSC': range(84, 250), 'SC': range(252, 385)},
    'ToothMuch': {'RSC': set(range(0, 156)).union(set(range(266, 385))), 'SC': range(190, 266)},
    'MimosaPudica': {'RSC': set(range(0, 176)).union(set(range(285, 385))), 'SC': range(179, 284)},
}

# ======================
# Key stems (EXACT substrings; adjust if your keys differ)
# ======================
# Relative-angle/distance domain (ETC, ETC′)
STEMS_REL = [
    "ETC", "Relative_head_angle", "Relative_distance", "Relative Distance"
]
# Walls (EBC)
STEMS_WALL = [
    "EBC", "Walls", "Wall", "Distance_to_wall", "Angle_to_wall"
]
# Objects (EOC) — add/remove tokens to match your naming
STEMS_EOC = ["ego_object-smoothed_rm_2d",
     "ETC", "Relative_head_angle", "Relative_distance", "Relative Distance"
]

# Suffixes
RM_SUFFIX  = "-smoothed_rm_2d"
OCC_SUFFIX = "-occ_2d"

# ======================
# Helpers
# ======================
_cell_re = re.compile(r"(imec\d+_cl\d+_ch)(\d+)$")
def parse_channel_from_cell(cell_prefix: str) -> int:
    m = _cell_re.search(cell_prefix or "")
    if m: return int(m.group(2))
    if "_ch" in (cell_prefix or ""):
        try: return int(cell_prefix.split("_ch")[-1])
        except: return -1
    return -1

def is_rsc_cell(cell_prefix: str, animal: str) -> bool:
    rsc = channel_ranges.get(animal, {}).get("RSC", set())
    return parse_channel_from_cell(cell_prefix) in rsc

def iter_pkl_paths(inputs):
    for p in inputs:
        if os.path.isdir(p):
            for q in glob.glob(os.path.join(p, "*.pkl")):
                yield q
        else:
            yield p

def find_exact_pair_keys(d: dict, cell: str, mode: str):
    """
    mode: "REL" (ETC/ETC′), "EOC_REL" (object), "WALL" (EBC)
    Returns (rm_key, occ_key) or (None, None)
    """
    candidates_rm = [k for k in d.keys() if k.startswith(cell + "-") and k.endswith(RM_SUFFIX)]

    def has_any(name, stems): return any(s in name for s in stems)

    if mode == "REL":
        cand_rm = [k for k in candidates_rm if has_any(k, STEMS_REL) and not has_any(k, STEMS_WALL)]
    elif mode == "EOC_REL":
        cand_rm = [k for k in candidates_rm if has_any(k, STEMS_EOC) and not has_any(k, STEMS_WALL)]
    elif mode == "WALL":
        cand_rm = [k for k in candidates_rm if has_any(k, STEMS_WALL)]
    else:
        cand_rm = []

    # Prefer more specific/shorter names to avoid mixed tags
    cand_rm = sorted(cand_rm, key=len)

    for rm in cand_rm:
        occ = rm.replace(RM_SUFFIX, OCC_SUFFIX)
        if occ in d:
            return rm, occ
    return None, None

def load_condition_maps(inputs, which_animal, mode):
    """
    mode: "REL" (ETC/ETC′) | "EOC_REL" (object) | "WALL" (EBC)
    Returns: dict cell -> {"rm","occ"}
    """
    out = {}
    for p in iter_pkl_paths(inputs):
        if not os.path.exists(p):
            continue
        try:
            with open(p, "rb") as f:
                d = pickle.load(f)
        except Exception:
            continue

        cells = sorted({k.split("-")[0] for k in d if k.endswith(RM_SUFFIX)})
        for cell in cells:
            if not is_rsc_cell(cell, which_animal):
                continue
            rm_k, occ_k = find_exact_pair_keys(d, cell, mode)
            if rm_k and occ_k:
                out[cell] = {"rm": np.asarray(d[rm_k], float), "occ": np.asarray(d[occ_k], float)}
    return out

def debug_list_object_like_keys(inputs, sample_limit=12):
    """Print some keys that match EOC stems to help tuning STEMS_EOC."""
    print("[DEBUG] Scanning for EOC/Object-like keys…")
    hits = []
    for p in iter_pkl_paths(inputs):
        try:
            with open(p, "rb") as f: d = pickle.load(f)
        except Exception:
            continue
        for k in d.keys():
            if k.endswith(RM_SUFFIX) and (any(s in k for s in STEMS_EOC) and not any(s in k for s in STEMS_WALL)):
                hits.append(k)
                if len(hits) >= sample_limit:
                    break
        if len(hits) >= sample_limit:
            break
    if hits:
        print("[DEBUG] Example keys matched as EOC/Object:")
        for k in hits: print("   ", k)
    else:
        print("[DEBUG] No keys matched STEMS_EOC; add your exact tokens to STEMS_EOC.")

def corr_common_occ(a_rm, a_occ, b_rm, b_occ, min_overlap=0):
    a_rm, b_rm = np.asarray(a_rm, float), np.asarray(b_rm, float)
    a_occ, b_occ = np.asarray(a_occ, float), np.asarray(b_occ, float)
    H = min(a_rm.shape[0], b_rm.shape[0]); W = min(a_rm.shape[1], b_rm.shape[1])
    a_rm, b_rm = a_rm[:H,:W], b_rm[:H,:W]
    a_occ, b_occ = a_occ[:H,:W], b_occ[:H,:W]
    mask = (a_occ > 0) & (b_occ > 0) & np.isfinite(a_rm) & np.isfinite(b_rm)
    n = int(mask.sum())
    if n < max(2, min_overlap): return np.nan
    x = a_rm[mask].ravel(); y = b_rm[mask].ravel()
    x0, y0 = x - x.mean(), y - y.mean()
    denom = np.sqrt((x0*x0).sum() * (y0*y0).sum())
    return float((x0*y0).sum() / denom) if denom != 0 else np.nan

def gaussian_rate2d(angles, dists, spikes, angle_edges, dist_edges, sigma=1.0):
    occ2d, _, _ = np.histogram2d(angles, dists, bins=[angle_edges, dist_edges])
    spk2d, _, _ = np.histogram2d(angles, dists, bins=[angle_edges, dist_edges], weights=spikes)
    rate = np.zeros_like(occ2d, float)
    m = occ2d > 0
    rate[m] = spk2d[m] / occ2d[m]
    if sigma and sigma > 0:
        rate = gaussian_filter(rate, sigma=sigma)
    return rate, occ2d

def ecdf(arr):
    arr = np.asarray(arr, float); arr = arr[np.isfinite(arr)]
    if arr.size == 0: return np.array([]), np.array([])
    x = np.sort(arr); y = np.arange(1, x.size + 1)/x.size
    return x, y

def ecdf_counts(vals):
    vals = np.asarray(vals, float)
    if vals.size == 0: return np.array([]), np.array([])
    x, y = ecdf(vals); return x, y * len(vals)

# --------- Even/Odd from time series ----------
def compute_even_odd_ETC_from_time(etcpkl_path,
                                   angle_key=ANGLE_KEY, dist_key=DIST_KEY,
                                   angle_edges=ANGLE_EDGES, dist_edges=DIST_EDGES,
                                   sigma=SMOOTH_SIGMA):
    with open(etcpkl_path, "rb") as f:
        data = pickle.load(f)

    time_bins = np.asarray(data["time_bins"])
    poss = data["possiblecovariates"]
    ang = np.asarray(poss[angle_key])
    dist= np.asarray(poss[dist_key])

    startalts = np.asarray(data.get("startaltbins"))
    endalts   = np.asarray(data.get("endaltbins"))

    n = min(len(ang), len(dist), len(time_bins))
    time_bins = time_bins[:n]; ang, dist = ang[:n], dist[:n]

    even_mask = np.zeros(n, dtype=bool)
    odd_mask  = np.zeros(n, dtype=bool)
    for i, (s, e) in enumerate(zip(startalts, endalts)):
        m = (time_bins >= s) & (time_bins < e)
        if i % 2 == 0: even_mask |= m
        else:          odd_mask  |= m

    cell_names  = data["cell_names"]
    cell_spikes = data["cell_activities"]

    dt = float(np.median(np.diff(time_bins)))
    edges = np.concatenate(([time_bins[0] - dt/2.0], time_bins + dt/2.0))

    eo_maps = {}
    for idx, cell in enumerate(cell_names):
        if not is_rsc_cell(cell, WHICH_ANIMAL):  # RSC-only here too
            continue
        spike_times = cell_spikes[idx]
        spk_counts  = np.histogram(spike_times, bins=edges)[0][:n]
        rm_even, occ_even = gaussian_rate2d(ang[even_mask], dist[even_mask], spk_counts[even_mask],
                                            angle_edges, dist_edges, sigma)
        rm_odd,  occ_odd  = gaussian_rate2d(ang[odd_mask],  dist[odd_mask],  spk_counts[odd_mask],
                                            angle_edges, dist_edges, sigma)
        eo_maps[cell] = {"rm_even": rm_even, "occ_even": occ_even,
                         "rm_odd": rm_odd, "occ_odd": occ_odd}
    return eo_maps

# --------- Pairwise compare (returns rows & vector) ----------
def compare_pair(condA, condB, label, min_overlap=MIN_OVERLAP_BINS):
    keysA = set(condA.keys()); keysB = set(condB.keys())
    inter = sorted(keysA & keysB)
    print(f"[{label}] Cells A={len(keysA)} B={len(keysB)} ∩={len(inter)} (≤ min(A,B)={min(len(keysA),len(keysB))})")
    rows = []
    # small preview of asymmetries
    missingA = [k for k in (keysB - keysA)][:10]
    missingB = [k for k in (keysA - keysB)][:10]
    if missingA: print(f"[{label}] Present in B but missing in A (examples): {missingA}")
    if missingB: print(f"[{label}] Present in A but missing in B (examples): {missingB}")

    for c in inter:
        r = corr_common_occ(condA[c]["rm"], condA[c]["occ"],
                            condB[c]["rm"], condB[c]["occ"],
                            min_overlap)
        rows.append((c, r))
    rows = [(c, r) for (c, r) in rows if np.isfinite(r)]
    vals = np.array([r for _, r in rows], float)
    print(f"[{label}] Valid pairs after overlap: n={len(vals)}, mean={np.nanmean(vals):.3f}, median={np.nanmedian(vals):.3f}")
    return rows, vals

# --------- Plot helper: pair + EO in one figure ----------
def plot_pair_with_eo(v_pair, pair_label, v_eo, outbase):
    if len(v_pair) == 0 and len(v_eo) == 0:
        print(f"[PLOT] Skipping {outbase} — no data for both curves.")
        return
    plt.figure(figsize=(6,6))

    # Pair curve (points)
    if len(v_pair):
        x1, y1 = ecdf_counts(v_pair)
        plt.plot(x1, y1, 'o', markersize=4, label=pair_label)

    # ETC even vs odd (points)
    if len(v_eo):
        x2, y2 = ecdf_counts(v_eo)
        plt.plot(x2, y2, '^', markersize=4, label="ETC even vs odd")

    ymax = max([len(v) for v in [v_pair, v_eo] if len(v)] + [5])
    plt.xlim([-0.5, 1.0]); plt.ylim([0, ymax + 2])
    plt.xticks([-0.5, 0, 0.5, 1.0])
    plt.yticks(np.arange(0, ymax + 2, step=max(1, ymax//10 or 1)))
    plt.xlabel("Correlation (r)")
    plt.ylabel("Number of Cells")
    plt.title(f"Correlation Distribution — {pair_label} vs EO")
    plt.legend(loc='upper left')
    plt.tight_layout()
    plt.savefig(f"{outbase}.svg")
    plt.savefig(f"{outbase}.pdf")
    plt.savefig(f"{outbase}.png")
    plt.show()
    print(f"[PLOT] Saved {outbase}.(svg|pdf|png)")

# ======================
# Main
# ======================
def main():
    # Load each condition with strict stems per domain
    etc_full      = load_condition_maps(PERCELL_INPUTS_ETC,      WHICH_ANIMAL, mode="REL")
    ebc_full      = load_condition_maps(PERCELL_INPUTS_EBC,      WHICH_ANIMAL, mode="WALL")
    eoc_full      = load_condition_maps(PERCELL_INPUTS_EOC,      WHICH_ANIMAL, mode="EOC_REL")  # object!
    etcprime_full = load_condition_maps(PERCELL_INPUTS_ETC_PRIM, WHICH_ANIMAL, mode="REL")

    if not len(eoc_full):
        # help you discover real object tokens
        debug_list_object_like_keys(PERCELL_INPUTS_EOC)

    # ETC even/odd (time-resolved)
    eo_maps = compute_even_odd_ETC_from_time(TIME_RESOLVED_ETC)

    # Compute pairwise comparisons
    print("\n=== Pairwise Matched Comparisons ===")
    rows_etcvsebc,  v_etcvsebc  = compare_pair(etc_full, ebc_full,      "ETC vs EBC")
    rows_etcvseoc,  v_etcvseoc  = compare_pair(etc_full, eoc_full,      "ETC vs EOC")
    rows_etcvsetcP, v_etcvsetcP = compare_pair(etc_full, etcprime_full, "ETC vs ETC′")

    # ETC even vs odd (stability) — compute r per cell (RSC-filtered already in compute fn)
    rows_eo = []
    for c, d in eo_maps.items():
        r = corr_common_occ(d["rm_even"], d["occ_even"], d["rm_odd"], d["occ_odd"], MIN_OVERLAP_BINS)
        if np.isfinite(r):
            rows_eo.append((c, r))
    v_etc_eo = np.array([r for _, r in rows_eo], float)
    print(f"[ETC even vs odd] n={len(v_etc_eo)}, mean={np.nanmean(v_etc_eo):.3f}, median={np.nanmedian(v_etc_eo):.3f}")

    # Optional CSV of matched rows per comparison (kept separate to preserve true Ns)
    if CSV_OUT:
        with open(CSV_OUT, "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["comparison","cell","r"])
            for label, rows in [
                ("ETC_vs_EBC", rows_etcvsebc),
                ("ETC_vs_EOC", rows_etcvseoc),
                ("ETC_vs_ETCprime", rows_etcvsetcP),
                ("ETC_even_vs_odd", rows_eo),
            ]:
                for c, r in rows:
                    w.writerow([label, c, r])
        print(f"[INFO] Wrote {CSV_OUT}")

    # ---------- Three requested figures: each overlays PAIR with EO ----------
    plot_pair_with_eo(v_etcvsebc,  "ETC vs EBC",   v_etc_eo, "pair_ETCvsEBC_with_ETC_EO")
    plot_pair_with_eo(v_etcvseoc,  "ETC vs EOC",   v_etc_eo, "pair_ETCvsEOC_with_ETC_EO")
    plot_pair_with_eo(v_etcvsetcP, "ETC vs ETC′",  v_etc_eo, "pair_ETCvsETCprime_with_ETC_EO")

if __name__ == "__main__":
    main()


###### if only subset of cells then use this --
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, re, glob, pickle, csv
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# ======================
# CONFIG — set these
# ======================
WHICH_ANIMAL = "MimosaPudica"  # Arwen | Tauriel | PreciousGrape | ToothMuch | MimosaPudica

# Time-resolved ETC for even/odd (EO) computation
TIME_RESOLVED_ETC = "/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/rm_pre_data_mimosapudica_chasingmerged_EBC_ETC_XYZeuler_notricks_eo.pkl"

# Per-cell PKL folders (or files) that contain full-session maps
PERCELL_INPUTS_ETC      = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_chasing_ETC_EBC"]
PERCELL_INPUTS_EBC      = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_chasing_ETC_EBC"]
PERCELL_INPUTS_EOC      = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_objectmerged_day0_sqaure"]
PERCELL_INPUTS_ETC_PRIM = ["/Users/pearls/PycharmProjects/RateMap/mimosapudica/RSC_project/mimosapudica_nopursuitmerged"]  # ETC′ (no pursuit)

# Only use these cells
WHITELIST_CELLS = {
    "imec0_cl0186_ch313","imec0_cl0214_ch327","imec0_cl0217_ch330","imec0_cl0230_ch339",
    "imec0_cl0270_ch354","imec0_cl0320_ch374","imec0_cl0348_ch383","imec0_cl0443_ch043",
    "imec0_cl0444_ch044","imec0_cl0470_ch056","imec0_cl0474_ch058","imec0_cl0493_ch066",
    "imec0_cl0513_ch081","imec0_cl0523_ch078","imec0_cl0525_ch084","imec0_cl0529_ch083",
    "imec0_cl0542_ch088","imec0_cl0557_ch095","imec0_cl0574_ch102","imec0_cl0590_ch112",
    "imec0_cl0686_ch155"
}

# ETC covariates for time-resolved EO
ANGLE_KEY = 'S Relative_head_angle'
DIST_KEY  = 'T Relative_distance'

# 2D binning
ANGLE_EDGES = np.linspace(-180, 180, 37)   # 10° bins
DIST_EDGES  = np.linspace(0, 150, 31)      # 5 cm bins
SMOOTH_SIGMA = 1.0
MIN_OVERLAP_BINS = 20

# Optional CSV (set "" to skip)
CSV_OUT = ""  # e.g. "/tmp/whitelist_pairwise_corrs_with_eo.csv"

# ======================
# Channel map
# ======================
channel_ranges = {
    'Arwen': {'RSC': range(124, 385), 'SC': range(0, 124)},
    'Tauriel': {'RSC': range(190, 385), 'SC': range(0, 190)},
    'PreciousGrape': {'RSC': range(84, 250), 'SC': range(252, 385)},
    'ToothMuch': {'RSC': set(range(0, 156)).union(set(range(266, 385))), 'SC': range(190, 266)},
    'MimosaPudica': {'RSC': set(range(0, 176)).union(set(range(285, 385))), 'SC': range(179, 284)},
}

# ======================
# Key stems (EXACT substrings; adjust if your keys differ)
# ======================
# Relative-angle/distance domain (ETC, ETC′)
STEMS_REL = ["ETC", "Relative_head_angle", "Relative_distance", "Relative Distance"]
# Walls (EBC)
STEMS_WALL = ["EBC", "Walls", "Wall", "Distance_to_wall", "Angle_to_wall"]
# Objects (EOC) — add/remove tokens to match your naming
STEMS_EOC = ["ego_object",
     "ETC", "Relative_head_angle", "Relative_distance", "Relative Distance"
]

# Suffixes
RM_SUFFIX  = "-smoothed_rm_2d"
OCC_SUFFIX = "-occ_2d"

# ======================
# Helpers
# ======================
_cell_re = re.compile(r"(imec\d+_cl\d+_ch)(\d+)$")
def parse_channel_from_cell(cell_prefix: str) -> int:
    m = _cell_re.search(cell_prefix or "")
    if m: return int(m.group(2))
    if "_ch" in (cell_prefix or ""):
        try: return int(cell_prefix.split("_ch")[-1])
        except: return -1
    return -1

def is_rsc_cell(cell_prefix: str, animal: str) -> bool:
    rsc = channel_ranges.get(animal, {}).get("RSC", set())
    return parse_channel_from_cell(cell_prefix) in rsc

def iter_pkl_paths(inputs):
    for p in inputs:
        if os.path.isdir(p):
            for q in glob.glob(os.path.join(p, "*.pkl")):
                yield q
        else:
            yield p

def find_exact_pair_keys(d: dict, cell: str, mode: str):
    """
    mode: "REL" (ETC/ETC′), "EOC_REL" (object), "WALL" (EBC)
    Returns (rm_key, occ_key) or (None, None)
    """
    candidates_rm = [k for k in d.keys() if k.startswith(cell + "-") and k.endswith(RM_SUFFIX)]
    def has_any(name, stems): return any(s in name for s in stems)

    if mode == "REL":
        cand_rm = [k for k in candidates_rm if has_any(k, STEMS_REL) and not has_any(k, STEMS_WALL)]
    elif mode == "EOC_REL":
        cand_rm = [k for k in candidates_rm if has_any(k, STEMS_EOC) and not has_any(k, STEMS_WALL)]
    elif mode == "WALL":
        cand_rm = [k for k in candidates_rm if has_any(k, STEMS_WALL)]
    else:
        cand_rm = []

    cand_rm = sorted(cand_rm, key=len)  # prefer shorter/specific names
    for rm in cand_rm:
        occ = rm.replace(RM_SUFFIX, OCC_SUFFIX)
        if occ in d:
            return rm, occ
    return None, None

def load_condition_maps(inputs, which_animal, mode, whitelist: set):
    """
    mode: "REL" | "EOC_REL" | "WALL"
    Returns dict cell -> {"rm","occ"} for cells that are BOTH in RSC and whitelist.
    """
    out = {}
    for p in iter_pkl_paths(inputs):
        if not os.path.exists(p):
            continue
        try:
            with open(p, "rb") as f:
                d = pickle.load(f)
        except Exception:
            continue

        cells = sorted({k.split("-")[0] for k in d if k.endswith(RM_SUFFIX)})
        for cell in cells:
            if cell not in whitelist:       # whitelist gate
                continue
            if not is_rsc_cell(cell, which_animal):
                continue
            rm_k, occ_k = find_exact_pair_keys(d, cell, mode)
            if rm_k and occ_k:
                out[cell] = {"rm": np.asarray(d[rm_k], float), "occ": np.asarray(d[occ_k], float)}
    return out

def debug_list_object_like_keys(inputs, sample_limit=12):
    """Print keys that match EOC stems (to tune STEMS_EOC if needed)."""
    print("[DEBUG] Scanning for EOC/Object-like keys…")
    hits = []
    for p in iter_pkl_paths(inputs):
        try:
            with open(p, "rb") as f: d = pickle.load(f)
        except Exception:
            continue
        for k in d.keys():
            if k.endswith(RM_SUFFIX) and (any(s in k for s in STEMS_EOC) and not any(s in k for s in STEMS_WALL)):
                hits.append(k)
                if len(hits) >= sample_limit:
                    break
        if len(hits) >= sample_limit:
            break
    if hits:
        print("[DEBUG] Example keys matched as EOC/Object:")
        for k in hits: print("   ", k)
    else:
        print("[DEBUG] No keys matched STEMS_EOC; add your exact tokens to STEMS_EOC.")

def corr_common_occ(a_rm, a_occ, b_rm, b_occ, min_overlap=0):
    a_rm, b_rm = np.asarray(a_rm, float), np.asarray(b_rm, float)
    a_occ, b_occ = np.asarray(a_occ, float), np.asarray(b_occ, float)
    H = min(a_rm.shape[0], b_rm.shape[0]); W = min(a_rm.shape[1], b_rm.shape[1])
    a_rm, b_rm = a_rm[:H,:W], b_rm[:H,:W]
    a_occ, b_occ = a_occ[:H,:W], b_occ[:H,:W]
    mask = (a_occ > 0) & (b_occ > 0) & np.isfinite(a_rm) & np.isfinite(b_rm)
    n = int(mask.sum())
    if n < max(2, min_overlap): return np.nan
    x = a_rm[mask].ravel(); y = b_rm[mask].ravel()
    x0, y0 = x - x.mean(), y - y.mean()
    denom = np.sqrt((x0*x0).sum() * (y0*y0).sum())
    return float((x0*y0).sum() / denom) if denom != 0 else np.nan

def gaussian_rate2d(angles, dists, spikes, angle_edges, dist_edges, sigma=1.0):
    occ2d, _, _ = np.histogram2d(angles, dists, bins=[angle_edges, dist_edges])
    spk2d, _, _ = np.histogram2d(angles, dists, bins=[angle_edges, dist_edges], weights=spikes)
    rate = np.zeros_like(occ2d, float)
    m = occ2d > 0
    rate[m] = spk2d[m] / occ2d[m]
    if sigma and sigma > 0:
        rate = gaussian_filter(rate, sigma=sigma)
    return rate, occ2d

def ecdf(arr):
    arr = np.asarray(arr, float); arr = arr[np.isfinite(arr)]
    if arr.size == 0: return np.array([]), np.array([])
    x = np.sort(arr); y = np.arange(1, x.size + 1)/x.size
    return x, y

def ecdf_counts(vals):
    vals = np.asarray(vals, float)
    if vals.size == 0: return np.array([]), np.array([])
    x, y = ecdf(vals); return x, y * len(vals)

# --------- Even/Odd from time series ----------
def compute_even_odd_ETC_from_time(etcpkl_path,
                                   angle_key=ANGLE_KEY, dist_key=DIST_KEY,
                                   angle_edges=ANGLE_EDGES, dist_edges=DIST_EDGES,
                                   sigma=SMOOTH_SIGMA,
                                   whitelist: set = None):
    with open(etcpkl_path, "rb") as f:
        data = pickle.load(f)

    time_bins = np.asarray(data["time_bins"])
    poss = data["possiblecovariates"]
    ang = np.asarray(poss[angle_key])
    dist= np.asarray(poss[dist_key])

    startalts = np.asarray(data.get("startaltbins"))
    endalts   = np.asarray(data.get("endaltbins"))

    n = min(len(ang), len(dist), len(time_bins))
    time_bins = time_bins[:n]; ang, dist = ang[:n], dist[:n]

    even_mask = np.zeros(n, dtype=bool)
    odd_mask  = np.zeros(n, dtype=bool)
    for i, (s, e) in enumerate(zip(startalts, endalts)):
        m = (time_bins >= s) & (time_bins < e)
        if i % 2 == 0: even_mask |= m
        else:          odd_mask  |= m

    cell_names  = data["cell_names"]
    cell_spikes = data["cell_activities"]

    dt = float(np.median(np.diff(time_bins)))
    edges = np.concatenate(([time_bins[0] - dt/2.0], time_bins + dt/2.0))

    eo_maps = {}
    for idx, cell in enumerate(cell_names):
        if whitelist and cell not in whitelist:
            continue
        if not is_rsc_cell(cell, WHICH_ANIMAL):
            continue
        spike_times = cell_spikes[idx]
        spk_counts  = np.histogram(spike_times, bins=edges)[0][:n]
        rm_even, occ_even = gaussian_rate2d(ang[even_mask], dist[even_mask], spk_counts[even_mask],
                                            angle_edges, dist_edges, sigma)
        rm_odd,  occ_odd  = gaussian_rate2d(ang[odd_mask],  dist[odd_mask],  spk_counts[odd_mask],
                                            angle_edges, dist_edges, sigma)
        eo_maps[cell] = {"rm_even": rm_even, "occ_even": occ_even,
                         "rm_odd": rm_odd, "occ_odd": occ_odd}
    return eo_maps

# --------- Pairwise compare (whitelist-aware)
def compare_pair(condA, condB, label, min_overlap=MIN_OVERLAP_BINS):
    keysA = set(condA.keys()); keysB = set(condB.keys())
    inter = sorted(keysA & keysB)
    print(f"[{label}] In-whitelist A={len(keysA)} B={len(keysB)} ∩={len(inter)}")
    if len(inter) < len(WHITELIST_CELLS):
        missing = sorted(WHITELIST_CELLS - set(inter))
        if missing:
            print(f"[{label}] Missing whitelist cells (examples): {missing[:10]} (+{max(0,len(missing)-10)} more)")
    rows = []
    for c in inter:
        r = corr_common_occ(condA[c]["rm"], condA[c]["occ"],
                            condB[c]["rm"], condB[c]["occ"],
                            min_overlap)
        rows.append((c, r))
    rows = [(c, r) for (c, r) in rows if np.isfinite(r)]
    vals = np.array([r for _, r in rows], float)
    print(f"[{label}] Valid pairs after overlap: n={len(vals)}, mean={np.nanmean(vals):.3f}, median={np.nanmedian(vals):.3f}")
    return rows, vals, inter

# --------- Plot helper: pair + EO in one figure ----------
def plot_pair_with_eo(v_pair, pair_label, v_eo, outbase):
    if len(v_pair) == 0 and len(v_eo) == 0:
        print(f"[PLOT] Skipping {outbase} — no data for both curves.")
        return
    plt.figure(figsize=(6,6))
    if len(v_pair):
        x1, y1 = ecdf_counts(v_pair)
        plt.plot(x1, y1, 'o', markersize=4, label=pair_label)
    if len(v_eo):
        x2, y2 = ecdf_counts(v_eo)
        plt.plot(x2, y2, '^', markersize=4, label="ETC even vs odd")
    ymax = max([len(v) for v in [v_pair, v_eo] if len(v)] + [5])
    plt.xlim([-0.5, 1.0]); plt.ylim([0, ymax + 2])
    plt.xticks([-0.5, 0, 0.5, 1.0])
    plt.yticks(np.arange(0, ymax + 2, step=max(1, ymax//10 or 1)))
    plt.xlabel("Correlation (r)")
    plt.ylabel("Number of Cells")
    plt.title(f"Correlation Distribution — {pair_label} vs EO ")
    plt.legend(loc='upper left')
    plt.tight_layout()
    plt.savefig(f"{outbase}.svg"); plt.savefig(f"{outbase}.pdf"); plt.savefig(f"{outbase}.png")
    plt.show()
    print(f"[PLOT] Saved {outbase}.(svg|pdf|png)")

# ======================
# Main
# ======================
def main():
    # Load maps for whitelist cells only
    etc_full      = load_condition_maps(PERCELL_INPUTS_ETC,      WHICH_ANIMAL, mode="REL",     whitelist=WHITELIST_CELLS)
    ebc_full      = load_condition_maps(PERCELL_INPUTS_EBC,      WHICH_ANIMAL, mode="WALL",    whitelist=WHITELIST_CELLS)
    eoc_full      = load_condition_maps(PERCELL_INPUTS_EOC,      WHICH_ANIMAL, mode="EOC_REL", whitelist=WHITELIST_CELLS)
    etcprime_full = load_condition_maps(PERCELL_INPUTS_ETC_PRIM, WHICH_ANIMAL, mode="REL",     whitelist=WHITELIST_CELLS)

    # Debug if EOC is empty
    if not len(eoc_full):
        debug_list_object_like_keys(PERCELL_INPUTS_EOC)

    # ETC even/odd (time-resolved) for whitelist cells only
    eo_maps = compute_even_odd_ETC_from_time(TIME_RESOLVED_ETC, whitelist=WHITELIST_CELLS)

    # Pairwise comparisons using only cells present in both conditions (and in whitelist)
    print("\n=== Pairwise Matched Comparisons (Whitelist Only) ===")
    rows_etcvsebc,  v_etcvsebc,  inter_etcvsebc  = compare_pair(etc_full, ebc_full,      "ETC vs EBC")
    rows_etcvseoc,  v_etcvseoc,  inter_etcvseoc  = compare_pair(etc_full, eoc_full,      "ETC vs EOC")
    rows_etcvsetcP, v_etcvsetcP, inter_etcvsetcP = compare_pair(etc_full, etcprime_full, "ETC vs ETC′")

    # EO correlations computed only for whitelist; keep as a shared baseline
    rows_eo = []
    for c, d in eo_maps.items():
        r = corr_common_occ(d["rm_even"], d["occ_even"], d["rm_odd"], d["occ_odd"], MIN_OVERLAP_BINS)
        if np.isfinite(r):
            rows_eo.append((c, r))
    v_etc_eo = np.array([r for _, r in rows_eo], float)
    print(f"[ETC even vs odd] (whitelist) n={len(v_etc_eo)}, mean={np.nanmean(v_etc_eo):.3f}, median={np.nanmedian(v_etc_eo):.3f}")

    # Optional CSV
    if CSV_OUT:
        with open(CSV_OUT, "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["comparison","cell","r"])
            for label, rows in [
                ("ETC_vs_EBC", rows_etcvsebc),
                ("ETC_vs_EOC", rows_etcvseoc),
                ("ETC_vs_ETCprime", rows_etcvsetcP),
                ("ETC_even_vs_odd", rows_eo),
            ]:
                for c, r in rows:
                    w.writerow([label, c, r])
        print(f"[INFO] Wrote {CSV_OUT}")

    # Three requested figures (pair + EO)
    plot_pair_with_eo(v_etcvsebc,  "ETC vs EBC",   v_etc_eo, "WL_pair_ETCvsEBC_with_ETC_EO")
    plot_pair_with_eo(v_etcvseoc,  "ETC vs EOC",   v_etc_eo, "WL_pair_ETCvsEOC_with_ETC_EO")
    plot_pair_with_eo(v_etcvsetcP, "ETC vs ETC′",  v_etc_eo, "WL_pair_ETCvsETCprime_with_ETC_EO")

if __name__ == "__main__":
    main()
